Не пользоваться Dynamic вовсе. Или запилить потом для Dynamic особый генератор кода.
Вместо него разрешать использовать только Any. При работе с Dynamic, придётся отказаться от нативных генериков, и всё представлять в виде Dynamic, как это сделано в hxcpp. Всё из-за приведения типов к Dynamic, когда параметры генериков лёгко преобразуются к Dynamic. Это не даёт возможность использовать нативные генерики, где отсутствует такое приведение. С Any такой проблемы нет, Array<Int> не может легко стать Array<Any>, компилятор выдаст ошибку.
Если запилить всё как в hxcpp, то производительность таких программ сразу просядет.

1. Экземпляру объекта с помощью рефлексии нельзя добавить или удалить новые поля
2. Экземпляру объекта можно присвоить значение поля с помощью рефлексии
3. Анонимному объекту с помощью рефлексии можно добавит/удалить новые поля
4. Any-у можно добавить новые поля или удалить существующее, если dynamic был получен от анонимного объекта.
Если от экземпляра класса то нельзя
5. Так же рефлексией можно проверить есть ли поле у объекта, получить поле по имени, получить все поля, вызвать метод по имени

Объекты можно разделить на типы:
1. Без рефлексии (HaxeObject). Нет никакой метаинформации. Нет возможности получать список полей. Изменять/удалять поля.
Для классов, которые не учавствуют в рефлексии и не преобразуются в AnyType.
2. Неизменяемый с интроспекцией (IntrospectionHaxeObject). Есть метаинформация о полях, можно получать список полей. Изменять значения полей. Вызывать методы по имени. Нет возможности добавить новые поля и удалять поля.
Для классов, которые учавствуют в рефлексии, или преобразуются в AnyType.
3. С рефлексией (ReflectionHaxeObject). Можно всё.
Для анонимных объектов
4. Объект-интерфейс. Обёртка над другим объектом с полями, которые ссылаются на поля исходного объекта.
При конвертировании в AnyType или при рефлексии над ним используется исходный объект.

Передача объектов в функции:
1. Если передаётся экземпляр туда, где ожидается typedef, экземпляр конвертируется в потомка от InterfaceHaxeObjectRef, который подменяет поля на ссылки полей реального объекта
2. Все параметры функции с анонимным типом заменяются на потомков от InterfaceHaxeObjectRef